{"version":3,"sources":["ng://ng-image-lazy-load/src/lazy-load.directive.ts","ng://ng-image-lazy-load/src/lazy-load.module.ts"],"names":["LazyLoadDirective","_element","_zone","platformId","_this","this","entries","forEach","entry","checkIfIntersecting","load","_intersectionObserver","unobserve","isVisible","run","prototype","ngAfterViewInit","isPlatformBrowser","enableLazyLoad","hasCompatibleBrowser","registerIntersectionObserver","observe","addScrollListeners","hasIntersectionObserver","window","matches","navigator","userAgent","match","isEdge","length","isEdgeVersion16OrBetter","parseInt","ngOnDestroy","removeListeners","IntersectionObserver","checkForIntersection","Object","keys","isIntersecting","target","nativeElement","src","runOutsideAngular","_scrollSubscription","fromEvent","pipe","debounceTime","subscribe","onScroll","unsubscribe","disconnect","scrollPosition","getScrollPosition","getBoundingClientRect","top","scrollY","pageYOffset","document","documentElement","clientHeight","body","Directive","args","selector","ElementRef","NgZone","decorators","type","Inject","PLATFORM_ID","Input","LazyLoadModule","NgModule","imports","CommonModule","declarations","exports"],"mappings":"2aAAA,IAAAA,EAAA,WAcE,SAAAA,EAEUC,EACAC,EACqBC,GAJ/B,IAAAC,EAAAC,KAEUA,KAAAJ,SAAAA,EACAI,KAAAH,MAAAA,EACqBG,KAAAF,WAAAA,4BAiDA,SAACG,GAC9BA,EAAQC,QAAQ,SAACC,GACXJ,EAAKK,oBAAoBD,KAC3BJ,EAAKM,OACDN,EAAKO,uBACPP,EAAKO,sBAAsBC,UAAoBR,EAAKH,SAAsB,iCA0C/D,WACbG,EAAKS,aACPT,EAAKF,MAAMY,IAAI,WAAM,OAAAV,EAAKM,iBA9FvBV,EAAAe,UAAAC,2BACDC,EAAAA,kBAAkBZ,KAAKF,YACzBE,KAAKa,iBAGLb,KAAKK,QAIDV,EAAAe,UAAAG,0BAEFb,KAAKc,wBACPd,KAAKe,+BACDf,KAAKM,uBACPN,KAAKM,sBAAsBU,QAAkBhB,KAAKJ,SAAsB,gBAI1EI,KAAKiB,sBAIDtB,EAAAe,UAAAI,gCACN,IAAMI,EAA0B,yBAA0BC,OAEpDC,EADYD,OAAOE,UAAUC,UACTC,MAAM,kBAE1BC,IAAWJ,GAA4B,EAAjBA,EAAQK,OAC9BC,EAA0BF,KAAaJ,GAAsC,GAA3BO,SAASP,EAAQ,GAAI,IAE7E,OAAOF,KAA6BM,GAAUE,IAGzC/B,EAAAe,UAAAkB,uBACL5B,KAAK6B,mBAEClC,EAAAe,UAAAK,mDACAf,KAAKM,wBAGXN,KAAKM,sBAAwB,IAAIwB,qBAAqB,SAAA7B,GACpDF,EAAKgC,qBAAqB9B,IACzB,MAaGN,EAAAe,UAAAN,6BAAoBD,GAG1B,OAAIA,GAAS6B,OAAOC,KAAK9B,GAAOsB,OACvB,EAAaS,gBAAkB/B,EAAMgC,SAAWnC,KAAKJ,SAASwC,cAEhEpC,KAAKQ,aAGNb,EAAAe,UAAAL,gBACNL,KAAK6B,kBAEL7B,KAAKJ,SAASwC,cAAcC,IAAMrC,KAAKqC,KAGjC1C,EAAAe,UAAAO,yCACFjB,KAAKQ,YACPR,KAAKK,OAGPL,KAAKH,MAAMyC,kBAAkB,WAC3BvC,EAAKwC,oBAAsBC,EAAAA,UAAUrB,OAAQ,UAC1CsB,KAAKC,EAAAA,aAAa,KAClBC,UAAU5C,EAAK6C,aAIdjD,EAAAe,UAAAmB,2BACF7B,KAAKuC,qBACPvC,KAAKuC,oBAAoBM,cAGvB7C,KAAKM,uBACPN,KAAKM,sBAAsBwC,cAUvBnD,EAAAe,UAAAF,qBACN,IAAMuC,EAAiB/C,KAAKgD,oBAE5B,OADsBhD,KAAKJ,SAASwC,cAAca,wBAAwBC,KAClDH,GAGlBpD,EAAAe,UAAAsC,6BAEN,OAAQ7B,OAAOgC,SAAWhC,OAAOiC,cAC5BC,SAASC,gBAAgBC,cAAgBF,SAASG,KAAKD,mCA5H/DE,EAAAA,UAASC,KAAA,CAAC,CACTC,SAAU,6DANQC,EAAAA,kBAAsCC,EAAAA,cAkBb7B,OAAM8B,WAAA,CAAA,CAAAC,KAA9CC,EAAAA,OAAMN,KAAA,CAACO,EAAAA,+CANTC,EAAAA,WAZH,GCAAC,EAAA,oDAICC,EAAAA,SAAQV,KAAA,CAAC,CACRW,QAAS,CACPC,EAAAA,cAEFC,aAAc,CAAC5E,GACf6E,QAAS,CAAC7E,SATZ","sourcesContent":["import { Directive, ElementRef, AfterViewInit, OnDestroy, NgZone, PLATFORM_ID, Inject, Input } from '@angular/core';\nimport { isPlatformBrowser } from '@angular/common';\nimport { Subscription, fromEvent } from 'rxjs';\nimport { debounceTime } from 'rxjs/operators';\n\n@Directive({\n  selector: '[appLazyLoad]'\n})\nexport class LazyLoadDirective implements AfterViewInit, OnDestroy {\n\n  private _intersectionObserver?: IntersectionObserver;\n  private _scrollSubscription?: Subscription;\n  @Input() src: string;   // The image to be lazy loaded\n\n  constructor(\n\n    private _element: ElementRef,\n    private _zone: NgZone,\n    @Inject(PLATFORM_ID) private platformId: Object\n  ) {\n  }\n\n  public ngAfterViewInit() {\n    if (isPlatformBrowser(this.platformId)) {\n      this.enableLazyLoad();\n    } else {\n      // running on server, just load the image\n      this.load();\n    }\n  }\n\n  private enableLazyLoad() {\n    // Client only code.\n    if (this.hasCompatibleBrowser()) {\n      this.registerIntersectionObserver();\n      if (this._intersectionObserver) {\n        this._intersectionObserver.observe(<Element>(this._element.nativeElement));\n      }\n    } else {\n      // add scroll watch if intersection observer is not available\n      this.addScrollListeners();\n    }\n  }\n\n  private hasCompatibleBrowser(): boolean {\n    const hasIntersectionObserver = 'IntersectionObserver' in window;\n    const userAgent = window.navigator.userAgent;\n    const matches = userAgent.match(/Edge\\/(\\d*)\\./i);\n\n    const isEdge = !!matches && matches.length > 1;\n    const isEdgeVersion16OrBetter = isEdge && (!!matches && parseInt(matches[1], 10) > 15);\n\n    return hasIntersectionObserver && (!isEdge || isEdgeVersion16OrBetter);\n  }\n\n  public ngOnDestroy() {\n    this.removeListeners();\n  }\n  private registerIntersectionObserver(): void {\n    if (!!this._intersectionObserver) {\n      return;\n    }\n    this._intersectionObserver = new IntersectionObserver(entries => {\n      this.checkForIntersection(entries);\n    }, {});\n  }\n\n  private checkForIntersection = (entries: Array<IntersectionObserverEntry>) => {\n    entries.forEach((entry: IntersectionObserverEntry) => {\n      if (this.checkIfIntersecting(entry)) {\n        this.load();\n        if (this._intersectionObserver) {\n          this._intersectionObserver.unobserve(<Element>(this._element.nativeElement));\n        }\n      }\n    });\n  }\n  private checkIfIntersecting(entry: IntersectionObserverEntry) {\n    // For Samsung native browser, IO has been partially implemented where by the\n    // callback fires, but entry object is empty. We will check manually.\n    if (entry && Object.keys(entry).length) {\n      return (<any>entry).isIntersecting && entry.target === this._element.nativeElement;\n    }\n    return this.isVisible();\n  }\n\n  private load(): void {\n    this.removeListeners();\n    // this.deferLoad.emit();\n    this._element.nativeElement.src = this.src;\n  }\n\n  private addScrollListeners() {\n    if (this.isVisible()) {\n      this.load();\n      return;\n    }\n    this._zone.runOutsideAngular(() => {\n      this._scrollSubscription = fromEvent(window, 'scroll')\n        .pipe(debounceTime(50))\n        .subscribe(this.onScroll);\n    });\n  }\n\n  private removeListeners() {\n    if (this._scrollSubscription) {\n      this._scrollSubscription.unsubscribe();\n    }\n\n    if (this._intersectionObserver) {\n      this._intersectionObserver.disconnect();\n    }\n  }\n\n  private onScroll = () => {\n    if (this.isVisible()) {\n      this._zone.run(() => this.load());\n    }\n  }\n\n  private isVisible() {\n    const scrollPosition = this.getScrollPosition();\n    const elementOffset = this._element.nativeElement.getBoundingClientRect().top;\n    return elementOffset <= scrollPosition;\n  }\n\n  private getScrollPosition() {\n    // Getting screen size and scroll position for IE\n    return (window.scrollY || window.pageYOffset)\n      + (document.documentElement.clientHeight || document.body.clientHeight);\n  }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { LazyLoadDirective } from './lazy-load.directive';\n\n@NgModule({\n  imports: [\n    CommonModule\n  ],\n  declarations: [LazyLoadDirective],\n  exports: [LazyLoadDirective]\n})\nexport class LazyLoadModule { }\n"]}